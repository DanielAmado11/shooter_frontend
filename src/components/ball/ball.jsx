/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 models/ball/ball.gltf 
*/

import React, { useEffect, useLayoutEffect, useRef, useState } from "react";
import { useSphereCollaider } from "../Collaiders/collaiders";
import { useCharacterAnimation } from "@/contexts/CharacterAnimation";
import { trayectory_forces } from "@/utils/trayectory_forces";

export function Ball(props) {
  const { position, animationTime, direction, force, attemptShoot } = props;
  const { animationIndex, setAnimationIndex } = useCharacterAnimation();

  const { sphereCollaider, sphereCollaiderAPI } = useSphereCollaider({
    scale: [0.15, 0.15, 0.15],
    args: [0.15],
    position: trayectory_forces[position].ball_position,
    rotation: [0, 0, 0],
    mass: 0.2,
    type: "Dynamic",
    material: {
      friction: 0.5,
      restitution: 0.9,
    },
    name: "ball",
    onCollide: (e) => {},
  });

  const restartBall = () => {
    sphereCollaiderAPI.velocity.set(0, 0, 0);
    sphereCollaiderAPI.angularVelocity.set(0, 0, 0);
    sphereCollaiderAPI.position.set(
      trayectory_forces[position].ball_position[0],
      trayectory_forces[position].ball_position[1],
      trayectory_forces[position].ball_position[2]
    );
    setAnimationIndex(0);
  };

  useEffect(() => {
    restartBall();
  }, [position]);

  const shoot = () => {
    const force_ = trayectory_forces[position][direction][force];
    sphereCollaiderAPI.applyForce(force_, [0, 0, 0]);
    attemptShoot(3, restartBall);
  };

  useEffect(() => {
    switch (animationIndex) {
      case 1:
        setTimeout(() => {
          shoot();
        }, animationTime * 1000 - 500);
        break;
      default:
        break;
    }
  }, [animationIndex]);

  // document.getElementById("restart").addEventListener("click", () => {
  //   // restart ball position
  //   sphereCollaiderAPI.velocity.set(0, 0, 0);
  //   sphereCollaiderAPI.angularVelocity.set(0, 0, 0);
  //   sphereCollaiderAPI.position.set(
  //     trayectory_forces[position].ball_position[0],
  //     trayectory_forces[position].ball_position[1],
  //     trayectory_forces[position].ball_position[2]
  //   );
  // });

  return (
    <group dispose={null}>
      <mesh ref={sphereCollaider}>
        <sphereGeometry args={[0.15, 10, 10]} />
        <meshStandardMaterial color={"#B0B0B0"} />
      </mesh>
    </group>
  );
}
